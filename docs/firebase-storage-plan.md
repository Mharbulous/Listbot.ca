# Simplified Firebase Storage Plan (KISS Edition)

Last Updated: 2025-08-30

## Overview

**Core Simplification**: ALL files go through matters. No exceptions.

This eliminates confusion about where files belong and simplifies security rules. Firms that need general storage simply create a "General" matter for non-client documents.

**Key Principles:**

- One storage pattern to rule them all: `/firms/{firmId}/matters/{matterId}/uploads/{fileHash}.{ext}`
- Every upload attempt is logged (successful or duplicate)
- Simple, consistent security rules
- Clear audit trail for compliance
- Handles multi-client matters and pre-matter intake documents

**Note**: For complete data structure specifications, see [data-structures.md](./architecture.md) as the authoritative source.

## File Extension Standardization Policy

**All file extensions MUST use lowercase format throughout the system**, with one specific exception:

### Standardization Rules

- **Display**: All file extensions shown to users use lowercase (`.pdf`, `.docx`, `.jpg`)
- **Storage Paths**: Firebase Storage paths use lowercase extensions (`{fileHash}.pdf`)
- **Processing**: All file extension handling in code uses lowercase
- **Comparisons**: File type checks and mappings use lowercase extensions

### Source File Name Case Preservation

**File extension case preservation is documented in [data-structures/FileMetadata.md](./architecture/FileMetadata.md).**

- This preserves the source file's name exactly as it existed on the user's device
- Example: If user uploads `Report.PDF`, the originalName field stores `Report.PDF` exactly as the source file was named

### Implementation Examples

```javascript
// ✅ Correct - Display uses lowercase
const fileExtension = filename.split('.').pop().toLowerCase();
return `${fileSize} • ${fileExtension} • ${date}`;

// ✅ Correct - Storage uses lowercase
const extension = file.name.split('.').pop().toLowerCase();
const storagePath = `firms/${firmId}/uploads/${fileHash}.${extension}`;

// ✅ Correct - Source file metadata preserves case
const metadataRecord = {
  originalName: file.name, // Preserves source file name case: "Report.PDF"
  // ... other fields
};

// ❌ Incorrect - Don't use toUpperCase() for display
return `${fileSize} • ${fileExtension.toUpperCase()} • ${date}`;
```

### Rationale

- **Consistency**: Lowercase provides uniform display and prevents case-sensitivity issues
- **Compatibility**: Most file systems and web standards expect lowercase extensions
- **Historical Accuracy**: Source filenames preserved for audit and compliance purposes
- **User Experience**: Consistent lowercase display regardless of how source files were named

## Naming Conventions

**Matter IDs are auto-generated by Firestore**, with one reserved exception:

- **Firm general** (reserved): `general` - For firm resources, templates, and non-client documents
- **Regular matters**: Auto-generated Firestore document IDs (e.g., `abc123def456ghi789`)

**Note**: Client names are stored directly in matter documents as string arrays, not as ID references. See [SoloFirmMatters.md](./architecture/SoloFirmMatters.md) for complete matter schema.

## Storage Structure (Simplified)

```
Firebase Storage Root
└── /firms/{firmId}/matters/{matterId}/uploads/{fileHash}.{ext}
```

That's it. One pattern. Every file follows this structure.

**Note**: Complete storage structure documentation is maintained in [data-structures.md - Firebase Storage Structure](./architecture.md#firebase-storage-structure).

### Reserved Matter ID

Each firm has one reserved matter ID:

- **`general`** - Firm resources, templates, and non-client documents

All other matter IDs are auto-generated by Firestore when creating new matter documents.

### Multi-Client Matters

Matters can have multiple clients - client names are stored as a string array directly in the matter document. For complete matter data structure including the `clients[]` field, see [SoloFirmMatters.md](./architecture/SoloFirmMatters.md).

## File Storage Implementation

### 1. Upload Service (Simple & Complete)

```javascript
class StorageService {
  async uploadFile(file, firmId, matterId, metadata = {}) {
    // 1. Calculate hash
    const fileHash = await this.calculateBLAKE3(file);
    const extension = file.name.split('.').pop().toLowerCase(); // Standardize to lowercase
    const fileName = `${fileHash}.${extension}`;
    const storagePath = `firms/${firmId}/matters/${matterId}/uploads/${fileName}`;

    // 2. Create upload event record (ALWAYS, even for duplicates)
    const eventId = await this.logUploadEvent({
      eventType: 'upload_success',
      timestamp: new Date(),
      fileName: file.name,
      fileHash,
      metadataHash: await this.calculateMetadataHash(file),
      firmId,
      userId: auth.currentUser.uid,
    });

    // 3. Check if file exists
    const fileRef = storage.ref(storagePath);
    const exists = await this.checkFileExists(fileRef);

    if (exists) {
      // 4a. File exists - create evidence record
      const evidenceId = await this.createEvidenceRecord({
        ...metadata,
        fileHash,
        isDuplicate: true,
        uploadEventId: eventId,
      });

      return {
        success: true,
        isDuplicate: true,
        storagePath,
        evidenceId,
        eventId,
      };
    }

    // 4b. New file - upload it
    await fileRef.put(file);

    // 5. Create evidence record
    const evidenceId = await this.createEvidenceRecord({
      ...metadata,
      fileHash,
      isDuplicate: false,
      uploadEventId: eventId,
    });

    return {
      success: true,
      isDuplicate: false,
      storagePath,
      evidenceId,
      eventId,
    };
  }

  async calculateBLAKE3(file) {
    const buffer = await file.arrayBuffer();
    const uint8Array = new Uint8Array(buffer);
    // Generate BLAKE3 hash with 128-bit output (16 bytes = 32 hex characters)
    const hash = await blake3(uint8Array, 128);
    return hash;
  }
}
```

### 2. Data Storage Implementation

**Important**: All file metadata data structures are definitively documented in **[data-structures/FileMetadata.md](./architecture/FileMetadata.md)**, which provides comprehensive coverage of file metadata collections, deduplication architecture, and the critical distinction between source file metadata versus Firebase storage file metadata.

## Security Rules

**Security rules are maintained in [data-structures.md - Security Rules](./architecture.md#security-rules) as the authoritative source.**

Key security principles:

- Firm members can only access their own firm's files
- Matter-based file organization provides natural access boundaries
- Evidence records and upload events are immutable once created
- Source metadata records use hash-based deduplication

## Matter-Based File Organization

### Isolation Through Matters

Since ALL files go through matters, document organization is simple and secure:

- **Each matter** → Unique auto-generated Firestore ID
- **Firm files** → Reserved `general` ID
- **Multi-client matters** → Client names stored in matter's `clients[]` array

### Multi-Client Matter Workflow

When creating matters with multiple clients (e.g., husband & wife estate planning):

```javascript
// Lawyer creates new matter for joint clients
const matterRef = await db
  .collection('firms')
  .doc(firmId)
  .collection('matters')
  .add({
    description: 'Smith Estate Planning',
    clients: ['John Smith', 'Jane Smith'], // Array of client name strings
    adverseParties: [],
    status: 'active',
    archived: false,
    assignedTo: [lawyerId],
    responsibleLawyer: lawyerId,
    createdAt: new Date(),
    createdBy: lawyerId,
  });

// Upload documents to the matter
const matterId = matterRef.id; // Auto-generated Firestore ID
uploadFile(file, firmId, matterId);
```

### Security Benefits

1. **Clear boundaries**: Each matter is a security boundary
2. **Simple isolation**: Matter-based access control prevents mixing documents
3. **No ID management**: Firestore auto-generates unique IDs
4. **Audit trail**: All document uploads tracked by matter

````

## Tracking & Audit Trail

### Every Upload is Logged
```javascript
// Example: User uploads same file 3 times to different matters
// Result: 1 file in storage, 3 upload_logs records

// Log 1: New file to matter-123
{
  logId: 'log-001',
  fileName: 'Contract.pdf',
  fileHash: 'abc123',
  matterId: 'matter-123',
  wasDuplicate: false,  // First upload
  wasSuccessful: true
}

// Log 2: Same file to matter-456
{
  logId: 'log-002',
  fileName: 'Contract_Final.pdf',  // Different name, same content
  fileHash: 'abc123',              // Same hash!
  matterId: 'matter-456',
  wasDuplicate: true,               // Detected duplicate
  wasSuccessful: true
}

// Log 3: Upload failed (network error)
{
  logId: 'log-003',
  fileName: 'Contract.pdf',
  fileHash: 'abc123',
  matterId: 'matter-789',
  wasDuplicate: true,
  wasSuccessful: false,
  error: 'Network timeout'
}
````

### Useful Query Patterns

```javascript
// File metadata querying patterns are documented in FileMetadata.md
// See data-structures/FileMetadata.md for complete query examples
```

## Implementation Phases

### Phase 1: Core Upload (Week 1)

- [ ] BLAKE3 calculation
- [ ] Basic upload to matter folders
- [ ] Document reference creation
- [ ] Upload logging
- [ ] Create reserved `general` system matter

### Phase 2: Search & Retrieval (Week 2)

- [ ] Document search by name/tags
- [ ] Matter document aggregation
- [ ] Download functionality
- [ ] Upload history viewing

### Phase 3: Nice-to-haves (If needed)

- [ ] Bulk upload
- [ ] File preview
- [ ] Document association/linking between matters

## Practical Workflows

### New Matter Creation Flow

```javascript
// 1. Lawyer creates new matter for client
const matterRef = await db
  .collection('firms')
  .doc(firmId)
  .collection('matters')
  .add({
    description: 'Smith Divorce Case',
    clients: ['John Smith'], // Client name string
    adverseParties: ['Jane Smith'],
    status: 'active',
    archived: false,
    assignedTo: [lawyerId],
    responsibleLawyer: lawyerId,
    createdAt: new Date(),
    createdBy: lawyerId,
  });

const matterId = matterRef.id; // Firestore auto-generated ID

// 2. Upload matter documents
await uploadFile(consultationNotes, firmId, matterId);
await uploadFile(retainerAgreement, firmId, matterId);
```

### Joint Client Matter Flow

```javascript
// 1. Create matter with multiple clients
const matterRef = await db
  .collection('firms')
  .doc(firmId)
  .collection('matters')
  .add({
    description: 'Smith Estate Planning',
    clients: ['John Smith', 'Jane Smith'], // Multiple client names
    adverseParties: [],
    status: 'active',
    archived: false,
    assignedTo: [lawyerId],
    responsibleLawyer: lawyerId,
    createdAt: new Date(),
    createdBy: lawyerId,
  });

const matterId = matterRef.id;

// 2. Upload documents to joint matter
await uploadFile(estatePlanningDocs, firmId, matterId);
await uploadFile(jointAssets, firmId, matterId);
```

## Benefits of This Simplified Approach

1. **One Pattern**: Developers only learn one file path pattern
2. **Consistent Security**: Same rules apply to all files
3. **Simple Data Model**: No separate Clients collection to manage
4. **Complete Audit Trail**: Every upload attempt is logged
5. **Efficient Storage**: BLAKE3 deduplication still works perfectly
6. **Auto-Generated IDs**: No manual ID management required
7. **Future-Proof**: Can add features without changing core structure

## Common Operations

```javascript
// Upload documents to a matter
await storageService.uploadFile(
  file,
  firmId,
  matterId, // Firestore auto-generated ID or 'general' for firm files
  {
    displayName: 'Tax Returns',
    tags: ['financial', 'tax'],
    folderPath: '/client-documents/2025',
  }
);

// Upload to firm resources (reserved ID)
await storageService.uploadFile(
  file,
  firmId,
  'general', // Reserved ID for firm-wide files
  {
    displayName: 'Firm Handbook 2024',
    tags: ['handbook', 'policy'],
    folderPath: '/firm-resources',
  }
);

// File metadata record creation patterns documented in FileMetadata.md
```

**Note**: These examples show the implementation pattern. Complete method signatures and error handling should follow the data structures defined in [data-structures.md](./architecture.md).

## Required Indexes

**Firestore indexes are documented in [data-structures.md - Required Firestore Indexes](./architecture.md#required-firestore-indexes) as the authoritative source.**

Key indexes needed:

- Evidence collection queries by file hash and timestamps
- Upload events by matter and timestamp
- Original metadata by hash lookups
- Tag-based searches on evidence records

Remember: **Start simple, add complexity only when real usage patterns demand it.**
