import { ref } from 'vue';

/**
 * Composable for category edit CRUD actions
 * Handles loading, saving, deleting categories and notifications
 *
 * @param {Object} params - Configuration object
 * @param {Object} params.category - Reactive reference to the category
 * @param {Object} params.editedCategory - Reactive reference to the edited category
 * @param {Object} params.originalType - Reactive reference to the original type
 * @param {Object} params.categorySource - Reactive reference to the category source
 * @param {Object} params.categoryManager - Category manager composable
 * @param {Object} params.route - Vue Router route object
 * @param {Object} params.router - Vue Router instance
 * @param {Function} params.validateCategory - Validation function
 * @param {Object} params.autoGeneratedExamples - Computed regex examples
 * @returns {Object} Action methods and state
 */
export function useCategoryEditActions({
  category,
  editedCategory,
  originalType,
  categorySource,
  categoryManager,
  route,
  router,
  validateCategory,
  autoGeneratedExamples,
}) {
  const loading = ref(true);
  const saving = ref(false);
  const snackbar = ref({ show: false, message: '', color: 'success' });

  const showNotification = (message, color = 'success') => {
    snackbar.value = { show: true, message, color };
  };

  const loadCategory = async () => {
    loading.value = true;
    try {
      const categoryId = route.params.id;

      // Load all categories from all three sources
      await categoryManager.loadAllCategories();

      // Find the category from the appropriate source
      let foundCategory = null;
      if (categorySource.value === 'system') {
        foundCategory = categoryManager.systemcategories.value.find((cat) => cat.id === categoryId);
      } else if (categorySource.value === 'firm') {
        foundCategory = categoryManager.firmCategories.value.find((cat) => cat.id === categoryId);
      } else if (categorySource.value === 'matter') {
        foundCategory = categoryManager.matterCategories.value.find((cat) => cat.id === categoryId);
      }

      if (!foundCategory) {
        category.value = null;
        showNotification('Category not found', 'error');
        return;
      }

      category.value = foundCategory;
      originalType.value = foundCategory.type;

      // Populate editedCategory with existing values
      editedCategory.value = {
        name: foundCategory.name || '',
        type: foundCategory.type || 'Fixed List',
        tags: foundCategory.tags || [],
        defaultCurrency: foundCategory.defaultCurrency || 'CAD',
        defaultSequenceFormat: foundCategory.defaultSequenceFormat || '1, 2, 3, ...',
        defaultBooleanFormat: foundCategory.defaultBooleanFormat || 'TRUE/FALSE',
        regexDefinition: foundCategory.regexDefinition || '.*',
        allowDuplicateValues: foundCategory.allowDuplicateValues || false,
        allowGaps: foundCategory.allowGaps || false,
      };
    } catch (error) {
      showNotification('Failed to load category: ' + error.message, 'error');
      category.value = null;
    } finally {
      loading.value = false;
    }
  };

  const saveCategory = async () => {
    if (!validateCategory()) return;

    saving.value = true;
    try {
      const updates = {
        name: editedCategory.value.name.trim(),
        type: editedCategory.value.type,
      };

      // Add tags for Fixed List and Open List types
      if (['Fixed List', 'Open List'].includes(editedCategory.value.type)) {
        updates.tags = editedCategory.value.tags;
      }

      // Add type-specific fields
      if (editedCategory.value.type === 'Currency') {
        updates.defaultCurrency = editedCategory.value.defaultCurrency;
      }

      if (editedCategory.value.type === 'Sequence') {
        updates.defaultSequenceFormat = editedCategory.value.defaultSequenceFormat;
        updates.allowGaps = editedCategory.value.allowGaps;
      }

      if (editedCategory.value.type === 'Boolean') {
        updates.defaultBooleanFormat = editedCategory.value.defaultBooleanFormat;
      }

      if (editedCategory.value.type === 'Regex') {
        updates.regexDefinition = editedCategory.value.regexDefinition.trim();
        updates.regexExamples = autoGeneratedExamples.value.join(', ');
      }

      if (['Text Area', 'Sequence', 'Regex'].includes(editedCategory.value.type)) {
        updates.allowDuplicateValues = editedCategory.value.allowDuplicateValues;
      }

      // Use category manager composable which will update the correct collection based on source
      await categoryManager.updateCategory(category.value.id, updates, categorySource.value);

      showNotification(`Category "${updates.name}" updated successfully`, 'success');

      // Navigate back to category manager after a brief delay
      setTimeout(() => {
        router.push({ name: 'category-manager', params: { matterId: route.params.matterId } });
      }, 1500);
    } catch (error) {
      showNotification('Failed to update category: ' + error.message, 'error');
      saving.value = false;
    }
  };

  const deleteCategory = async () => {
    try {
      // Prevent deletion of system categories
      if (categorySource.value === 'system') {
        showNotification('System categories cannot be deleted', 'error');
        return;
      }

      const categoryName = category.value.name;
      await categoryManager.deleteCategory(category.value.id, categorySource.value);
      showNotification(`Category "${categoryName}" deleted successfully`, 'success');
      setTimeout(() => {
        router.push({ name: 'category-manager', params: { matterId: route.params.matterId } });
      }, 1500);
    } catch (error) {
      showNotification('Failed to delete category: ' + error.message, 'error');
    }
  };

  return {
    loading,
    saving,
    snackbar,
    loadCategory,
    saveCategory,
    deleteCategory,
    showNotification,
  };
}
