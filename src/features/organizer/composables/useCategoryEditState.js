import { ref, computed } from 'vue';
import { useRouter } from 'vue-router';
import { useCategoryManager } from './useCategoryManager.js';
import { categoryTypeOptions } from '../utils/categoryTypes.js';
import { capitalizeFirstLetter } from '../utils/categoryFormHelpers.js';
import {
  getAllowedTypeConversions,
  requiresWarning,
  getConversionWarningMessage,
} from '../utils/categoryTypeConversions.js';

/**
 * Composable for managing category edit state and CRUD operations
 * @param {Object} params - Configuration parameters
 * @param {Ref} params.categorySource - Source of the category (system/firm/matter)
 * @param {Ref} params.autoGeneratedExamples - Auto-generated regex examples
 * @param {Function} params.validateCategory - Validation function
 * @param {Function} params.showNotification - Notification function
 * @returns {Object} State management and CRUD methods
 */
export function useCategoryEditState({
  categorySource,
  autoGeneratedExamples,
  validateCategory,
  showNotification,
}) {
  const router = useRouter();
  const categoryManager = useCategoryManager();

  // Loading and saving states
  const loading = ref(true);
  const saving = ref(false);

  // Category data
  const category = ref(null);
  const originalType = ref(null);

  // Edited category state
  const editedCategory = ref({
    name: '',
    type: '',
    tags: [],
    defaultCurrency: 'CAD',
    defaultSequenceFormat: '1, 2, 3, ...',
    regexDefinition: '.*',
    allowDuplicateValues: false,
    allowGaps: false,
  });

  // Category validation errors
  const categoryErrors = ref({
    name: [],
    type: [],
    defaultCurrency: [],
    defaultSequenceFormat: [],
    regexDefinition: [],
    allowDuplicateValues: [],
    allowGaps: [],
  });

  // Type conversion warning dialog state
  const pendingType = ref(null);
  const showWarningDialog = ref(false);
  const conversionWarningMessage = ref('');

  // Computed property to get allowed type options based on current type
  const allowedTypeOptions = computed(() => {
    if (!originalType.value) return categoryTypeOptions;

    const allowedTypes = getAllowedTypeConversions(originalType.value);
    return categoryTypeOptions.filter((option) => allowedTypes.includes(option.value));
  });

  // Computed property to check if there are changes
  const hasChanges = computed(() => {
    if (!category.value) return false;

    // Compare all relevant fields
    const fields = [
      'name',
      'type',
      'defaultCurrency',
      'defaultSequenceFormat',
      'regexDefinition',
      'allowDuplicateValues',
      'allowGaps',
    ];

    // Special handling for tags array comparison
    if (category.value.tags || editedCategory.value.tags) {
      const originalTags = category.value.tags || [];
      const editedTags = editedCategory.value.tags || [];

      if (originalTags.length !== editedTags.length) {
        return true;
      }

      // Compare tag names (order-independent)
      const originalNames = originalTags.map((t) => t.name).sort();
      const editedNames = editedTags.map((t) => t.name).sort();

      if (JSON.stringify(originalNames) !== JSON.stringify(editedNames)) {
        return true;
      }
    }

    return fields.some((field) => {
      const originalValue = category.value[field];
      const editedValue = editedCategory.value[field];

      // Handle undefined/null comparison
      if (originalValue === undefined || originalValue === null) {
        return editedValue !== undefined && editedValue !== null;
      }

      return originalValue !== editedValue;
    });
  });

  // Computed property to check if current category is a system category
  const isSystemCategoryComputed = computed(() => {
    return categorySource.value === 'system';
  });

  /**
   * Capitalize first letters of category name
   */
  const capitalizeFirstLetters = (event) => {
    editedCategory.value.name = capitalizeFirstLetter(event.target.value);
  };

  /**
   * Handle type change with warning dialog if needed
   */
  const handleTypeChange = (newType) => {
    // Check if this change requires a warning
    if (requiresWarning(originalType.value, newType)) {
      pendingType.value = newType;
      conversionWarningMessage.value = getConversionWarningMessage(originalType.value, newType);
      showWarningDialog.value = true;
    } else {
      applyTypeChange(newType);
    }
  };

  /**
   * Apply type change and handle data transformations
   */
  const applyTypeChange = (newType) => {
    // Handle data transformations based on type change
    if (newType === 'Regex' && originalType.value === 'Sequence') {
      // Set default regex when converting from Sequence
      if (!editedCategory.value.regexDefinition || editedCategory.value.regexDefinition === '.*') {
        editedCategory.value.regexDefinition = '.*';
      }
    }
  };

  /**
   * Confirm type change from warning dialog
   */
  const confirmTypeChange = () => {
    showWarningDialog.value = false;
    if (pendingType.value) {
      applyTypeChange(pendingType.value);
      pendingType.value = null;
    }
  };

  /**
   * Cancel type change and revert to original
   */
  const cancelTypeChange = () => {
    showWarningDialog.value = false;
    // Revert type back to original
    editedCategory.value.type = originalType.value;
    pendingType.value = null;
  };

  /**
   * Load category data
   */
  const loadCategory = async (categoryId) => {
    loading.value = true;
    try {
      // Load all categories from all three sources
      await categoryManager.loadAllCategories();

      // Find the category from the appropriate source
      let foundCategory = null;
      if (categorySource.value === 'system') {
        foundCategory = categoryManager.systemcategories.value.find((cat) => cat.id === categoryId);
      } else if (categorySource.value === 'firm') {
        foundCategory = categoryManager.firmCategories.value.find((cat) => cat.id === categoryId);
      } else if (categorySource.value === 'matter') {
        foundCategory = categoryManager.matterCategories.value.find((cat) => cat.id === categoryId);
      }

      if (!foundCategory) {
        category.value = null;
        showNotification('Category not found', 'error');
        return;
      }

      category.value = foundCategory;
      originalType.value = foundCategory.type;

      // Populate editedCategory with existing values
      editedCategory.value = {
        name: foundCategory.name || '',
        type: foundCategory.type || 'Fixed List',
        tags: foundCategory.tags || [],
        defaultCurrency: foundCategory.defaultCurrency || 'CAD',
        defaultSequenceFormat: foundCategory.defaultSequenceFormat || '1, 2, 3, ...',
        regexDefinition: foundCategory.regexDefinition || '.*',
        allowDuplicateValues: foundCategory.allowDuplicateValues || false,
        allowGaps: foundCategory.allowGaps || false,
      };
    } catch (error) {
      showNotification('Failed to load category: ' + error.message, 'error');
      category.value = null;
    } finally {
      loading.value = false;
    }
  };

  /**
   * Save category changes
   */
  const saveCategory = async () => {
    if (!(await validateCategory())) return;

    saving.value = true;
    try {
      const updates = {
        name: editedCategory.value.name.trim(),
        type: editedCategory.value.type,
      };

      // Add tags for Fixed List and Open List types
      if (['Fixed List', 'Open List'].includes(editedCategory.value.type)) {
        updates.tags = editedCategory.value.tags;
      }

      // Add type-specific fields
      if (editedCategory.value.type === 'Currency') {
        updates.defaultCurrency = editedCategory.value.defaultCurrency;
      }

      if (editedCategory.value.type === 'Sequence') {
        updates.defaultSequenceFormat = editedCategory.value.defaultSequenceFormat;
        updates.allowGaps = editedCategory.value.allowGaps;
      }

      if (editedCategory.value.type === 'Regex') {
        updates.regexDefinition = editedCategory.value.regexDefinition.trim();
        updates.regexExamples = autoGeneratedExamples.value.join(', ');
      }

      if (['Text Area', 'Sequence', 'Regex'].includes(editedCategory.value.type)) {
        updates.allowDuplicateValues = editedCategory.value.allowDuplicateValues;
      }

      // Use category manager composable which will update the correct collection based on source
      await categoryManager.updateCategory(category.value.id, updates, categorySource.value);

      showNotification(`Category "${updates.name}" updated successfully`, 'success');

      // Navigate back to category viewer after a brief delay
      setTimeout(() => {
        router.push({ name: 'CategoryMigrationTool' });
      }, 1500);
    } catch (error) {
      showNotification('Failed to update category: ' + error.message, 'error');
      saving.value = false;
    }
  };

  /**
   * Delete category
   */
  const deleteCategory = async () => {
    try {
      // Prevent deletion of system categories
      if (categorySource.value === 'system') {
        showNotification('System categories cannot be deleted', 'error');
        return;
      }

      const categoryName = category.value.name;
      await categoryManager.deleteCategory(category.value.id, categorySource.value);
      showNotification(`Category "${categoryName}" deleted successfully`, 'success');
      setTimeout(() => {
        router.push({ name: 'CategoryMigrationTool' });
      }, 1500);
    } catch (error) {
      showNotification('Failed to delete category: ' + error.message, 'error');
    }
  };

  return {
    // State
    loading,
    saving,
    category,
    originalType,
    editedCategory,
    categoryErrors,
    showWarningDialog,
    conversionWarningMessage,

    // Computed
    allowedTypeOptions,
    hasChanges,
    isSystemCategoryComputed,

    // Methods
    capitalizeFirstLetters,
    handleTypeChange,
    confirmTypeChange,
    cancelTypeChange,
    loadCategory,
    saveCategory,
    deleteCategory,
  };
}
