import { ref, computed } from 'vue';
import { useCategoryManager } from './useCategoryManager.js';
import { categoryTypeOptions } from '../utils/categoryTypes.js';
import { currencyOptions } from '../utils/currencyOptions.js';
import { sequenceFormatOptions } from '../utils/categoryFormOptions.js';
import { generateRegexExamples, isRegexDefinitionValid } from '../utils/categoryFormHelpers.js';
import {
  checkForDuplicateSystemCategory,
  getCategoryConflictErrors,
} from '../utils/categoryIdGenerator.js';

/**
 * Composable for managing category edit validation
 * @param {Object} params - Configuration parameters
 * @param {Ref} params.categorySource - Source of the category (system/firm/matter)
 * @param {Ref} params.category - Current category being edited
 * @param {Ref} params.editedCategory - Edited category data
 * @param {Ref} params.categoryErrors - Category validation errors
 * @returns {Object} Validation state and methods
 */
export function useCategoryEditValidation({
  categorySource,
  category,
  editedCategory,
  categoryErrors,
}) {
  const categoryManager = useCategoryManager();

  // State for duplicate checking
  const systemCategoriesForValidation = ref([]);

  // Computed property to check for duplicate names/IDs (only for system categories)
  const duplicateCheck = computed(() => {
    // Only check duplicates for system categories
    if (categorySource.value !== 'system') {
      return { nameConflict: false, idConflict: false, conflictingCategory: null, generatedId: '' };
    }

    if (!editedCategory.value.name.trim()) {
      return { nameConflict: false, idConflict: false, conflictingCategory: null, generatedId: '' };
    }

    return checkForDuplicateSystemCategory(
      editedCategory.value.name,
      systemCategoriesForValidation.value,
      category.value?.id || null
    );
  });

  // Computed properties for conflict detection
  const hasNameConflict = computed(() => duplicateCheck.value.nameConflict);
  const hasIdConflict = computed(() => duplicateCheck.value.idConflict);
  const hasAnyConflict = computed(() => hasNameConflict.value || hasIdConflict.value);

  // Computed property to auto-generate regex examples
  const autoGeneratedExamples = computed(() => {
    if (editedCategory.value.type !== 'Regex') {
      return [];
    }
    return generateRegexExamples(editedCategory.value.regexDefinition);
  });

  // Computed property to check if regex is valid
  const isRegexValid = computed(() => {
    // If not a Regex type, always valid
    if (editedCategory.value.type !== 'Regex') {
      return true;
    }
    // Check if regex is valid based on generated examples
    return isRegexDefinitionValid(editedCategory.value.regexDefinition, autoGeneratedExamples.value);
  });

  // Computed property for real-time name validation error messages
  const nameErrorMessages = computed(() => {
    const name = editedCategory.value.name.trim();
    const errors = [];

    // Don't show errors for empty field
    if (!name) return errors;

    // Check length
    if (name.length > 50) {
      errors.push('Category name must be 50 characters or less');
    }

    // For system categories, check for ID/name conflicts
    if (categorySource.value === 'system') {
      const conflictErrors = getCategoryConflictErrors(duplicateCheck.value);
      errors.push(...conflictErrors);
    }

    return errors;
  });

  // Computed property to check if form is valid
  const isFormValid = computed(() => {
    const name = editedCategory.value.name.trim();
    const type = editedCategory.value.type;

    return (
      name.length >= 3 &&
      type &&
      (editedCategory.value.type !== 'Currency' || editedCategory.value.defaultCurrency) &&
      (editedCategory.value.type !== 'Sequence' || editedCategory.value.defaultSequenceFormat) &&
      isRegexValid.value &&
      (!['Text Area', 'Sequence', 'Regex'].includes(editedCategory.value.type) ||
        typeof editedCategory.value.allowDuplicateValues === 'boolean') &&
      (editedCategory.value.type !== 'Sequence' ||
        typeof editedCategory.value.allowGaps === 'boolean')
    );
  });

  /**
   * Validate category before saving
   * @returns {Promise<boolean>} True if validation passes
   */
  const validateCategory = async () => {
    const nameErrors = [];
    const typeErrors = [];
    const defaultCurrencyErrors = [];
    const defaultSequenceFormatErrors = [];
    const allowDuplicateValuesErrors = [];
    const allowGapsErrors = [];
    const regexDefinitionErrors = [];

    const name = editedCategory.value.name.trim();
    const type = editedCategory.value.type;
    const defaultCurrency = editedCategory.value.defaultCurrency;
    const defaultSequenceFormat = editedCategory.value.defaultSequenceFormat;
    const regexDefinition = editedCategory.value.regexDefinition;
    const allowDuplicateValues = editedCategory.value.allowDuplicateValues;
    const allowGaps = editedCategory.value.allowGaps;

    // Load categories from the appropriate source for duplicate checking
    let categoriesToCheck = [];
    if (categorySource.value === 'system') {
      categoriesToCheck = await categoryManager.loadsystemcategories();
      systemCategoriesForValidation.value = categoriesToCheck;
    } else {
      await categoryManager.loadAllCategories();
      categoriesToCheck =
        categorySource.value === 'firm'
          ? categoryManager.firmCategories.value
          : categoryManager.matterCategories.value;
    }

    // Validate name - check for both name and ID conflicts (for system categories)
    if (!name) {
      nameErrors.push('Category name is required');
    } else if (name.length > 50) {
      nameErrors.push('Category name must be 50 characters or less');
    } else if (categorySource.value === 'system') {
      // For system categories, use the shared validation utility to check for conflicts
      const conflictErrors = getCategoryConflictErrors(duplicateCheck.value);
      nameErrors.push(...conflictErrors);
    } else {
      // For firm/matter categories, just check for duplicate names
      if (
        categoriesToCheck.some(
          (cat) => cat.id !== category.value.id && cat.name.toLowerCase() === name.toLowerCase()
        )
      ) {
        nameErrors.push('Category name already exists');
      }
    }

    // Validate type
    if (!type) {
      typeErrors.push('Category type is required');
    } else if (!categoryTypeOptions.find((option) => option.value === type)) {
      typeErrors.push('Please select a valid category type');
    }

    // Validate currency-specific fields
    if (type === 'Currency') {
      if (!defaultCurrency) {
        defaultCurrencyErrors.push('Default currency is required for Currency categories');
      } else if (!currencyOptions.find((option) => option.value === defaultCurrency)) {
        defaultCurrencyErrors.push('Please select a valid currency');
      }
    }

    // Validate sequence-specific fields (for Sequence only)
    if (type === 'Sequence') {
      if (!defaultSequenceFormat) {
        defaultSequenceFormatErrors.push('Sequence format is required for Sequence categories');
      } else if (!sequenceFormatOptions.find((option) => option.value === defaultSequenceFormat)) {
        defaultSequenceFormatErrors.push('Please select a valid sequence format');
      }
    }

    // Validate allow duplicate values for applicable types
    if (['Text Area', 'Sequence', 'Regex'].includes(type)) {
      if (typeof allowDuplicateValues !== 'boolean') {
        allowDuplicateValuesErrors.push('Allow duplicate values setting is required');
      }
    }

    // Validate allow gaps for Sequence type
    if (type === 'Sequence') {
      if (typeof allowGaps !== 'boolean') {
        allowGapsErrors.push('Allow gaps setting is required');
      }
    }

    // Validate regex-specific fields (for Regex only)
    if (type === 'Regex') {
      if (!regexDefinition || !regexDefinition.trim()) {
        regexDefinitionErrors.push('Regex definition is required for Regex categories');
      } else {
        // Basic regex syntax validation
        try {
          new RegExp(regexDefinition.trim());
        } catch (e) {
          regexDefinitionErrors.push('Invalid regex syntax: ' + e.message);
        }
      }
    }

    categoryErrors.value.name = nameErrors;
    categoryErrors.value.type = typeErrors;
    categoryErrors.value.defaultCurrency = defaultCurrencyErrors;
    categoryErrors.value.defaultSequenceFormat = defaultSequenceFormatErrors;
    categoryErrors.value.regexDefinition = regexDefinitionErrors;
    categoryErrors.value.allowDuplicateValues = allowDuplicateValuesErrors;
    categoryErrors.value.allowGaps = allowGapsErrors;

    return (
      nameErrors.length === 0 &&
      typeErrors.length === 0 &&
      defaultCurrencyErrors.length === 0 &&
      defaultSequenceFormatErrors.length === 0 &&
      regexDefinitionErrors.length === 0 &&
      allowDuplicateValuesErrors.length === 0 &&
      allowGapsErrors.length === 0
    );
  };

  /**
   * Load system categories for validation
   * @returns {Promise<void>}
   */
  const loadSystemCategoriesForValidation = async () => {
    if (categorySource.value === 'system') {
      await categoryManager.loadAllCategories();
      systemCategoriesForValidation.value = categoryManager.systemcategories.value;
    }
  };

  return {
    // State
    systemCategoriesForValidation,

    // Computed
    duplicateCheck,
    hasNameConflict,
    hasIdConflict,
    hasAnyConflict,
    autoGeneratedExamples,
    isRegexValid,
    nameErrorMessages,
    isFormValid,

    // Methods
    validateCategory,
    loadSystemCategoriesForValidation,
  };
}
