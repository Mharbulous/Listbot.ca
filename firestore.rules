rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Users collection - users can read/write their own document
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Development testing collections (global access for development)
    match /devTesting/{document} {
      allow read, write: if request.auth != null;  // Any authenticated user can access dev collections

      // TestTags subcollection
      match /TestTags/{tagId} {
        allow read, write: if request.auth != null;
      }
    }

    // System Categories collection (read-only for authenticated users)
    match /systemCategories/{categoryId} {
      // Any authenticated user can read system categories
      allow read: if request.auth != null;
      // Only admins or system processes can write (in production, this would be restricted to admin roles)
      allow write: if false;  // Prevent client-side writes - use server-side functions for seeding
    }

    // Firms collection - firm-based access control
    match /firms/{firmId} {
      // Allow read if user is authenticated and is a member of the firm
      allow read: if request.auth != null &&
        (
          // Check custom claims for firmId (preferred for SSO)
          request.auth.token.firmId == firmId ||
          // Solo user fallback: allow if firmId equals userId
          firmId == request.auth.uid ||
          // Fallback: check if user is listed as a member in the firm document
          request.auth.uid in resource.data.members.keys()
        );

      // Allow write if user is authenticated and is an admin of the firm
      allow write: if request.auth != null &&
        (
          // Check if user has admin role in custom claims
          (request.auth.token.firmId == firmId && request.auth.token.role == 'admin') ||
          // Solo user fallback: allow if firmId equals userId (solo users are admins)
          firmId == request.auth.uid ||
          // Fallback: check if user is an admin member in the firm document
          (request.auth.uid in resource.data.members.keys() &&
           resource.data.members[request.auth.uid].role == 'admin')
        );

      // Allow create if user is authenticated (for initial firm creation)
      allow create: if request.auth != null;
    }

    // Evidence documents with AI tags subcollection
    match /firms/{firmId}/evidence/{evidenceId} {
      // Firm members can read/write evidence documents
      allow read, write: if request.auth != null &&
        (
          // Check custom claims for firmId
          request.auth.token.firmId == firmId ||
          // Solo user fallback: allow if firmId equals userId
          firmId == request.auth.uid ||
          // Fallback: check firm membership
          exists(/databases/$(database)/documents/firms/$(firmId)) &&
          request.auth.uid in get(/databases/$(database)/documents/firms/$(firmId)).data.members.keys()
        );

      // AI tags subcollection for evidence documents
      match /Tags/{tagId} {
        // Firm members can read/write AI tags for evidence in their firm
        allow read, write: if request.auth != null &&
          (
            // Check custom claims for firmId
            request.auth.token.firmId == firmId ||
            // Solo user fallback: allow if firmId equals userId
            firmId == request.auth.uid ||
            // Fallback: check firm membership
            exists(/databases/$(database)/documents/firms/$(firmId)) &&
            request.auth.uid in get(/databases/$(database)/documents/firms/$(firmId)).data.members.keys()
          ) &&
          // Additional validation for AI tag data structure
          (
            // For create operations, ensure required fields are present
            (request.method != 'create' ||
             (resource == null &&
              request.resource.data.keys().hasAll(['categoryId', 'categoryName', 'tagName', 'color', 'source', 'createdAt']) &&
              request.resource.data.source == 'ai' &&
              request.resource.data.confidence is number &&
              request.resource.data.confidence >= 0 &&
              request.resource.data.confidence <= 100)) &&
            // For update operations, allow status changes and approvals
            (request.method != 'update' ||
             (resource != null &&
              // Core tag fields shouldn't change
              request.resource.data.categoryId == resource.data.categoryId &&
              request.resource.data.tagName == resource.data.tagName &&
              // Allow source change from 'ai' to 'human' for approvals
              (request.resource.data.source == resource.data.source ||
               (resource.data.source == 'ai' && request.resource.data.source == 'human'))))
          );
      }
    }

    // Tag subcollections for evidence documents (legacy support)
    match /firms/{firmId}/evidence/{evidenceId}/tags/{tagId} {
      // Firm members can read/write tags for evidence in their firm
      allow read, write: if request.auth != null &&
        (
          // Check custom claims for firmId
          request.auth.token.firmId == firmId ||
          // Solo user fallback: allow if firmId equals userId
          firmId == request.auth.uid ||
          // Fallback: check firm membership
          exists(/databases/$(database)/documents/firms/$(firmId)) &&
          request.auth.uid in get(/databases/$(database)/documents/firms/$(firmId)).data.members.keys()
        ) &&
        // Additional validation for tag data structure
        (
          // For create operations, ensure required fields are present
          (request.method != 'create' ||
           (resource == null &&
            request.resource.data.keys().hasAll(['categoryId', 'categoryName', 'tagName', 'color', 'source', 'createdAt', 'createdBy']))) &&
          // For update operations, ensure core fields aren't changed inappropriately
          (request.method != 'update' ||
           (resource != null &&
            request.resource.data.categoryId == resource.data.categoryId &&
            request.resource.data.tagName == resource.data.tagName &&
            request.resource.data.source == resource.data.source))
        );
    }

    // Firm-specific data collections (clients, matters, documents, etc.)
    match /firms/{firmId}/{collection}/{document} {
      // Users can access firm data if they're firm members
      allow read, write: if request.auth != null &&
        (
          // Check custom claims for firmId
          request.auth.token.firmId == firmId ||
          // Solo user fallback: allow if firmId equals userId
          firmId == request.auth.uid ||
          // Fallback: check firm membership (requires additional read)
          exists(/databases/$(database)/documents/firms/$(firmId)) &&
          request.auth.uid in get(/databases/$(database)/documents/firms/$(firmId)).data.members.keys()
        );
    }

    // Nested firm collections (e.g., matters with subcollections)
    match /firms/{firmId}/{collection}/{document}/{subcollection}/{subdocument} {
      allow read, write: if request.auth != null &&
        (
          request.auth.token.firmId == firmId ||
          firmId == request.auth.uid ||
          (exists(/databases/$(database)/documents/firms/$(firmId)) &&
           request.auth.uid in get(/databases/$(database)/documents/firms/$(firmId)).data.members.keys())
        );
    }

    // Evidence sourceMetadata subcollection (explicit rule for clarity)
    match /firms/{firmId}/matters/{matterId}/evidence/{evidenceId}/sourceMetadata/{metadataHash} {
      allow read, write: if request.auth != null &&
        (
          request.auth.token.firmId == firmId ||
          firmId == request.auth.uid ||
          (exists(/databases/$(database)/documents/firms/$(firmId)) &&
           request.auth.uid in get(/databases/$(database)/documents/firms/$(firmId)).data.members.keys())
        );
    }

    // Global admin access (optional - for super admins)
    match /{document=**} {
      allow read, write: if request.auth != null &&
        request.auth.token.role == 'superadmin';
    }

    // Default: deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}