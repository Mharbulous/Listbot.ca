# Phase 1.5: Virtualization with TanStack

**Phase:** 1.5 of 7
**Status:** Not Started (Blocked by Phase 1.0)
**Priority:** High
**Estimated Duration:** 2-3 days
**Dependencies:** Phase 1.0 must be complete and bug-free

---

## Overview

Add TanStack Virtual to the working Phase 1.0 table to enable high-performance rendering of large file lists. This phase is purely a **performance optimization** - no functionality changes, only implementation improvements.

**Goal:** Enable smooth handling of 1000+ files with minimal memory footprint
**Deliverable:** Virtualized table with constant O(1) memory usage and 60 FPS scrolling
**User Impact:** Users can now upload thousands of files without performance degradation

---

## Why Phase 1.5 Exists

**Prerequisites:**
- Phase 1.0 must be **complete and bug-free**
- All core upload, display, and status logic must be working
- Baseline performance metrics must be documented

**Benefits of splitting virtualization:**
✅ **Simplified Debugging:** Core logic proven before optimization
✅ **Clean Separation:** Functional changes vs. performance changes
✅ **Risk Mitigation:** Can rollback to Phase 1.0 if issues arise
✅ **Clear Metrics:** Before/after performance comparison

**This phase changes:**
- Table rendering implementation (standard → virtual)
- Scroll performance characteristics
- Memory usage patterns

**This phase does NOT change:**
- Upload button behavior
- Drag-and-drop functionality (continues to recursively traverse folders from Phase 1.0)
- Queue management logic
- Status system
- Footer calculations
- Any user-facing functionality

---

## What is Virtual Scrolling?

### The Problem (Phase 1.0)
With standard rendering, Vue creates DOM elements for **all** rows:
```
1000 files = 1000 <tr> elements in the DOM
10000 files = 10000 <tr> elements in the DOM
```
Result: Slow rendering, high memory usage, poor scroll performance

### The Solution (Phase 1.5)
With virtual scrolling, only **visible** rows are rendered:
```
1000 files visible viewport = ~20 <tr> elements in the DOM
10000 files visible viewport = ~20 <tr> elements in the DOM
```
Result: Fast rendering, constant memory, smooth 60 FPS scrolling

### How TanStack Virtual Works
1. Calculates which rows are visible in the viewport
2. Renders only those rows + a small overscan buffer
3. Uses CSS transforms to position rows correctly
4. Reuses DOM elements as user scrolls
5. Provides smooth scrolling with minimal memory

---

## Implementation Changes

### Before: Standard Rendering (Phase 1.0)

```vue
<template>
  <div class="table-scroll-container">
    <table class="upload-table">
      <tbody>
        <!-- Renders ALL rows -->
        <tr v-for="file in uploadQueue" :key="file.id">
          <UploadTableRow :file="file" />
        </tr>
      </tbody>
    </table>
  </div>
</template>
```

### After: Virtual Rendering (Phase 1.5)

```vue
<script setup>
import { useVirtualizer } from '@tanstack/vue-virtual';

const scrollContainer = ref(null);
const ROW_HEIGHT = 48;

const rowVirtualizer = useVirtualizer({
  count: uploadQueue.value.length,
  getScrollElement: () => scrollContainer.value,
  estimateSize: () => ROW_HEIGHT,
  overscan: 5,
  enableSmoothScroll: true
});

const virtualItems = computed(() => rowVirtualizer.value.getVirtualItems());
const totalSize = computed(() => rowVirtualizer.value.getTotalSize());
</script>

<template>
  <div ref="scrollContainer" class="table-scroll-container">
    <!-- Virtual container with full height -->
    <div class="virtual-container" :style="{ height: totalSize + 'px' }">
      <!-- Only renders visible rows + overscan -->
      <div
        v-for="virtualRow in virtualItems"
        :key="virtualRow.key"
        class="table-row"
        :style="{
          position: 'absolute',
          top: 0,
          left: 0,
          height: virtualRow.size + 'px',
          transform: `translateY(${virtualRow.start}px)`
        }"
      >
        <UploadTableRow :file="uploadQueue[virtualRow.index]" />
      </div>
    </div>
  </div>
</template>
```

---

## Component Changes

### New Files to Create

```
src/features/upload/
└── composables/
    └── useVirtualScroll.js   # NEW: Virtual scrolling logic
```

### Files to Modify

```
src/features/upload/
├── components/
│   └── UploadTable.vue       # MODIFY: Add virtual scrolling
```

### useVirtualScroll.js Composable

```javascript
import { ref, computed, watch } from 'vue';
import { useVirtualizer } from '@tanstack/vue-virtual';

export function useVirtualScroll(uploadQueue, scrollContainer) {
  const ROW_HEIGHT = 48;
  const OVERSCAN_COUNT = 5;

  // Create virtualizer instance
  const rowVirtualizer = useVirtualizer({
    count: computed(() => uploadQueue.value.length),
    getScrollElement: () => scrollContainer.value,
    estimateSize: () => ROW_HEIGHT,
    overscan: OVERSCAN_COUNT,
    enableSmoothScroll: true
  });

  // Watch for queue changes and update virtualizer
  watch(
    () => uploadQueue.value.length,
    () => {
      rowVirtualizer.value.measure();
    }
  );

  // Computed properties for template
  const virtualItems = computed(() => rowVirtualizer.value.getVirtualItems());
  const totalSize = computed(() => rowVirtualizer.value.getTotalSize());

  // Helper to scroll to specific row
  const scrollToRow = (index) => {
    rowVirtualizer.value.scrollToIndex(index, {
      align: 'center',
      behavior: 'smooth'
    });
  };

  return {
    virtualItems,
    totalSize,
    scrollToRow,
    rowVirtualizer
  };
}
```

### Updated UploadTable.vue

```vue
<script setup>
import { ref } from 'vue';
import { useVirtualScroll } from '../composables/useVirtualScroll';
import UploadTableRow from './UploadTableRow.vue';

const props = defineProps({
  files: { type: Array, required: true }
});

const scrollContainer = ref(null);

// Use virtual scrolling composable
const { virtualItems, totalSize } = useVirtualScroll(
  computed(() => props.files),
  scrollContainer
);
</script>

<template>
  <div ref="scrollContainer" class="table-scroll-container">
    <!-- Sticky header (unchanged from Phase 1.0) -->
    <table class="upload-table">
      <thead class="table-header-sticky">
        <tr>
          <th class="col-actions">Actions</th>
          <th class="col-filename">File Name</th>
          <th class="col-size">Size</th>
          <th class="col-status">Status</th>
          <th class="col-folder">Folder Path</th>
          <th class="col-cancel">Cancel</th>
        </tr>
      </thead>
    </table>

    <!-- Virtual scrolling container -->
    <div class="virtual-container" :style="{ height: totalSize + 'px' }">
      <div
        v-for="virtualRow in virtualItems"
        :key="virtualRow.key"
        class="table-row"
        :style="{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: virtualRow.size + 'px',
          transform: `translateY(${virtualRow.start}px)`
        }"
      >
        <table class="row-table">
          <tbody>
            <UploadTableRow :file="files[virtualRow.index]" />
          </tbody>
        </table>
      </div>
    </div>
  </div>
</template>

<style scoped>
.table-scroll-container {
  overflow-y: auto;
  max-height: calc(100vh - 300px);
  position: relative;
}

.virtual-container {
  position: relative;
  width: 100%;
}

.table-row {
  display: block;
}

.row-table {
  width: 100%;
  table-layout: fixed;
}
</style>
```

---

## Implementation Tasks

### Day 1: Setup & Integration

#### 1.1 Install Dependencies
- [ ] Run `npm install @tanstack/vue-virtual`
- [ ] Verify package installation
- [ ] Update package.json and lock file

#### 1.2 Create Composable
- [ ] Create `useVirtualScroll.js` composable
- [ ] Implement virtualizer configuration
- [ ] Add queue length watcher
- [ ] Export virtual items and total size
- [ ] Add scrollToRow helper function

#### 1.3 Modify UploadTable.vue
- [ ] Import useVirtualScroll composable
- [ ] Replace v-for loop with virtual items loop
- [ ] Add virtual container div with dynamic height
- [ ] Add absolute positioning styles to rows
- [ ] Add transform translateY for row positioning

### Day 2: Testing & Optimization

#### 1.4 Performance Testing
- [ ] Test with 100 files (compare to Phase 1.0 baseline)
- [ ] Test with 500 files (compare to Phase 1.0 baseline)
- [ ] Test with 1000 files (should be dramatically better)
- [ ] Test with 5000 files (should maintain performance)
- [ ] Test with 10000+ files (stress test)
- [ ] Measure memory usage across all tests
- [ ] Document FPS during rapid scrolling

#### 1.5 Edge Cases
- [ ] Test adding files while scrolled down
- [ ] Test removing files while scrolled down
- [ ] Test status updates for off-screen files
- [ ] Test rapid scrolling up and down
- [ ] Test scroll position preservation
- [ ] Test with empty queue
- [ ] Test with single file

#### 1.6 Overscan Tuning
- [ ] Test different overscan values (3, 5, 10)
- [ ] Measure impact on performance
- [ ] Measure impact on scroll smoothness
- [ ] Choose optimal overscan value
- [ ] Document decision

### Day 3: Polish & Validation

#### 1.7 Visual Polish
- [ ] Ensure row alignment matches Phase 1.0
- [ ] Verify column widths match header
- [ ] Check hover states work correctly
- [ ] Verify sticky header positioning
- [ ] Test scroll bar appearance
- [ ] Ensure no visual glitches during scroll

#### 1.8 Integration Testing
- [ ] Test upload → display flow (unchanged functionality)
- [ ] Test footer updates with virtual scrolling
- [ ] Test status changes propagate correctly
- [ ] Test cancel button on virtualized rows
- [ ] Verify all Phase 1.0 functionality still works

#### 1.9 Performance Validation
- [ ] Confirm 60 FPS during scrolling
- [ ] Confirm O(1) memory usage
- [ ] Confirm <100ms initial render for 1000 files
- [ ] Confirm smooth scrolling for 10000+ files
- [ ] Document all metrics for comparison

---

## Testing Requirements

### Performance Tests (Critical)

```javascript
describe('Virtual Scrolling Performance', () => {
  it('renders 1000 files in <100ms', async () => {
    const start = performance.now();
    await loadQueue(generateFiles(1000));
    const duration = performance.now() - start;
    expect(duration).toBeLessThan(100);
    console.log(`[PHASE 1.5] 1000 files: ${duration}ms`);
  });

  it('renders 5000 files in <150ms', async () => {
    const start = performance.now();
    await loadQueue(generateFiles(5000));
    const duration = performance.now() - start;
    expect(duration).toBeLessThan(150);
    console.log(`[PHASE 1.5] 5000 files: ${duration}ms`);
  });

  it('maintains 60 FPS during rapid scrolling', async () => {
    await loadQueue(generateFiles(5000));
    const fps = await measureScrollFPS();
    expect(fps).toBeGreaterThanOrEqual(58); // Allow 2 FPS margin
    console.log(`[PHASE 1.5] Scroll FPS: ${fps}`);
  });

  it('maintains constant memory usage', async () => {
    const baseline = await measureMemory();
    await loadQueue(generateFiles(1000));
    const after1k = await measureMemory();
    await loadQueue(generateFiles(5000));
    const after5k = await measureMemory();

    // Memory should not scale with file count
    const growth1k = after1k - baseline;
    const growth5k = after5k - baseline;
    const ratio = growth5k / growth1k;

    // Should be close to 1:1, not 5:1
    expect(ratio).toBeLessThan(2);
    console.log(`[PHASE 1.5] Memory growth ratio: ${ratio}`);
  });
});
```

### Functionality Tests (Regression Prevention)

```javascript
describe('Virtual Scrolling Functionality', () => {
  it('displays correct files in viewport', () => {});
  it('updates when queue changes', () => {});
  it('preserves scroll position on updates', () => {});
  it('handles empty queue', () => {});
  it('handles single file', () => {});
  it('renders rows with correct data', () => {});
});

describe('Phase 1.0 Functionality Regression', () => {
  it('upload buttons still work', () => {});
  it('drag-and-drop still works (recursive folder traversal)', () => {});
  it('files appear in table immediately', () => {});
  it('status updates propagate correctly', () => {});
  it('footer counts update correctly', () => {});
  it('all 7 status states display correctly', () => {});
  it('cancel button works on virtualized rows', () => {});
});
```

### Visual Tests

```javascript
describe('Virtual Scrolling Visual Consistency', () => {
  it('row heights match Phase 1.0', () => {});
  it('column widths match header', () => {});
  it('hover states work correctly', () => {});
  it('no visual glitches during scroll', () => {});
  it('sticky header remains visible', () => {});
});
```

### Manual Testing Scenarios

1. **Performance Comparison:**
   - Load 500 files → Compare to Phase 1.0 baseline
   - Load 1000 files → Should be dramatically better than Phase 1.0
   - Load 5000 files → Should remain smooth
   - Scroll rapidly → Should maintain 60 FPS

2. **Edge Cases:**
   - Add files while scrolled to bottom
   - Remove files while scrolled to middle
   - Change status of off-screen file
   - Scroll to top, then bottom, then middle rapidly

3. **Regression Testing:**
   - Run all Phase 1.0 manual test scenarios
   - Test drag-and-drop with folders (verify recursive traversal still works)
   - Verify identical functionality
   - Verify identical visual appearance

---

## Success Criteria

### Performance Requirements (Must Achieve)
- [ ] 1000 files render in <100ms
- [ ] 5000 files render in <150ms
- [ ] Scrolling maintains 60 FPS (58+ acceptable)
- [ ] Memory usage stays constant O(1)
- [ ] No frame drops during status updates
- [ ] Scroll position preserved during queue updates

### Functionality Requirements (No Regressions)
- [ ] All Phase 1.0 functionality works identically
- [ ] Upload buttons unchanged
- [ ] Queue management unchanged
- [ ] Status system unchanged
- [ ] Footer calculations unchanged
- [ ] Visual appearance matches Phase 1.0

### Technical Requirements
- [ ] Only visible rows + overscan rendered
- [ ] DOM element count stays constant
- [ ] Virtual container height matches total content
- [ ] Row positioning uses CSS transforms
- [ ] No console warnings or errors

---

## Performance Benchmarks

### Target Performance (Phase 1.5)

| File Count | Target Render Time | Target Scroll FPS | Target Memory |
|------------|-------------------|-------------------|---------------|
| 100 files | <50ms | 60 FPS | ~50MB |
| 500 files | <75ms | 60 FPS | ~50MB |
| 1000 files | <100ms | 60 FPS | ~50MB |
| 5000 files | <150ms | 60 FPS | ~50MB |
| 10000 files | <200ms | 60 FPS | ~50MB |

### Comparison to Phase 1.0

Expected improvements:
- **Initial render:** 10-20x faster for 1000+ files
- **Scroll performance:** 2-4x better FPS
- **Memory usage:** 5-10x reduction (O(n) → O(1))

**Performance Logging:**
```javascript
console.log('[PHASE 1.5] Virtualizer initialized');
console.log('[PHASE 1.5] 1000 files rendered: Xms (vs Phase 1.0: Yms)');
console.log('[PHASE 1.5] Visible rows: X of Y total');
console.log('[PHASE 1.5] Scroll FPS: X (vs Phase 1.0: Y)');
console.log('[PHASE 1.5] Memory: XMB (vs Phase 1.0: YMB)');
console.log('[PHASE 1.5] DOM elements: X (vs Phase 1.0: Y)');
```

---

## Dependencies

### NPM Packages (New)
```bash
npm install @tanstack/vue-virtual
```

### Internal Dependencies
- Phase 1.0 components (all unchanged except UploadTable.vue)
- DocumentTable.css (styling reference)

---

## Rollout Plan

### Development Schedule

**Day 1:** Install TanStack, create composable, integrate with UploadTable.vue
**Day 2:** Performance testing, edge case testing, overscan tuning
**Day 3:** Visual polish, regression testing, final validation

### Testing Steps
1. Performance benchmarks (compare to Phase 1.0)
2. Functionality regression tests
3. Edge case testing
4. Visual consistency checks
5. Browser compatibility
6. Final validation

### Deployment
- Deploy to `/testing` route (replace Phase 1.0)
- Announce performance improvements
- Monitor for any issues
- Keep Phase 1.0 code in git history for rollback if needed
- Collect user feedback on performance

---

## Known Issues / Risks

### Technical Risks
| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Virtual scrolling breaks existing functionality | Low | High | Comprehensive regression testing |
| Performance targets not met | Low | Medium | Can adjust overscan, row height |
| Visual glitches during scroll | Low | Medium | CSS refinement, browser testing |
| TanStack Virtual compatibility issues | Very Low | High | Well-established library, good docs |

### Rollback Plan
If Phase 1.5 introduces bugs or doesn't meet performance targets:
1. Revert UploadTable.vue to Phase 1.0 version
2. Remove useVirtualScroll.js
3. Can uninstall @tanstack/vue-virtual (optional)
4. Phase 1.0 remains fully functional

---

## Next Phase Preview

**Phase 2:** Core Actions
- Cancel button implementation
- Undo functionality
- Upload Now button
- Duplicate promotion algorithm

Phase 2 adds user actions to the high-performance virtualized table.

---

## Notes

- Phase 1.5 is **purely a performance optimization**
- No functionality changes - only implementation changes
- Must not introduce any bugs or regressions
- All Phase 1.0 tests must continue to pass
- Document before/after metrics for team review
- Keep code changes isolated to UploadTable.vue and new composable
- Can be rolled back to Phase 1.0 if needed

---

**Phase Status:** ⬜ Not Started (Blocked by Phase 1.0)
**Last Updated:** 2025-11-10
**Assignee:** TBD
