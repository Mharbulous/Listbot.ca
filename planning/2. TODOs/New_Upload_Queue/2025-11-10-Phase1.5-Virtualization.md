# Phase 1.5: Virtualization with TanStack

**Phase:** 1.5 of 7
**Status:** Not Started (Blocked by Phase 1.0)
**Priority:** High
**Estimated Duration:** 2-3 days
**Dependencies:** Phase 1.0 must be complete and bug-free

---

## üéØ STARTING POINT: Phase 1.0 Foundation (CRITICAL CONTEXT)

**‚ö†Ô∏è READ THIS FIRST - Phase 1.0 already created the architectural foundation for virtualization!**

### What Phase 1.0 Built For You

Phase 1.0 **proactively created** `UploadTableVirtualizer.vue` as an isolation layer for virtualization complexity:

**File:** `src/features/upload/components/UploadTableVirtualizer.vue`
**Current State (Phase 1.0):** ~140 lines using standard v-for rendering
**Your Job (Phase 1.5):** Modify this EXISTING file to add TanStack Virtual (~300-400 lines)

### Why This Component Exists

**Architectural Philosophy:**
- Virtual scrolling requires **tight coupling** between scroll position, visible items, and DOM positioning
- This coupling **cannot be decomposed** without breaking virtualization
- Therefore, this component is **intentionally isolated** to contain the complexity
- **All business logic stays in `UploadTable.vue`** - selection, stats, footer, empty state

### What's Already in UploadTableVirtualizer.vue (Phase 1.0)

```vue
<template>
  <div ref="scrollContainerRef" class="scroll-container">
    <div class="table-body">
      <!-- Standard rendering: Render ALL rows (Phase 1.0) -->
      <UploadTableRow
        v-for="file in props.files"
        :key="file.id"
        :file="file"
        :scrollbar-width="props.scrollbarWidth"
        @cancel="handleCancel"
        @undo="handleUndo"
      />
    </div>
  </div>
</template>
```

**Props:** `files` (Array), `scrollbarWidth` (Number)
**Emits:** `cancel`, `undo`
**Exposes:** `scrollContainerRef` (for parent's scrollbar width calculation)

### Your Task: Surgical Modification

**DO NOT:**
- ‚ùå Create a new component from scratch
- ‚ùå Move business logic into this component (selection, stats, etc.)
- ‚ùå Modify `UploadTable.vue` (parent) - it's already set up correctly
- ‚ùå Touch any other components

**DO:**
1. ‚úÖ Open `src/features/upload/components/UploadTableVirtualizer.vue`
2. ‚úÖ Add `import { useVirtualizer } from '@tanstack/vue-virtual'`
3. ‚úÖ Replace standard v-for with virtual scrolling loop
4. ‚úÖ Add absolute positioning and CSS transforms
5. ‚úÖ Keep the same props/emits/expose interface

**The component header has comprehensive documentation about what belongs in this file and what doesn't - READ IT!**

### ‚úÖ Pre-Implementation Checklist

**Before writing ANY code, confirm you understand:**

- [ ] `UploadTableVirtualizer.vue` **already exists** (created in Phase 1.0)
- [ ] I am **modifying an existing file**, not creating a new one
- [ ] The file is located at `src/features/upload/components/UploadTableVirtualizer.vue`
- [ ] `UploadTable.vue` (parent) **does not need changes** - it's already wired up
- [ ] The current implementation uses standard `v-for` rendering
- [ ] My job is to **replace** the v-for loop with TanStack Virtual
- [ ] I must **preserve** the props/emits/expose interface
- [ ] I must **NOT** add business logic (selection, stats, footer, empty state)
- [ ] I will **read the file header** before making changes
- [ ] I understand this file is **allowed** to exceed 300 lines (virtualization requires tight coupling)

**If you checked all boxes, proceed. If not, re-read the "STARTING POINT" section!**

---

## Overview

Add TanStack Virtual to the **existing** `UploadTableVirtualizer.vue` component to enable high-performance rendering of large file lists. This phase is purely a **performance optimization** - no functionality changes, only implementation improvements.

**Goal:** Enable smooth handling of 1000+ files with minimal memory footprint
**Deliverable:** Virtualized table with constant O(1) memory usage and 60 FPS scrolling
**User Impact:** Users can now upload thousands of files without performance degradation

**Component to Modify:** `src/features/upload/components/UploadTableVirtualizer.vue` (already exists from Phase 1.0)

---

## Why Phase 1.5 Exists

**Prerequisites:**
- Phase 1.0 must be **complete and bug-free**
- All core upload, display, and status logic must be working
- Baseline performance metrics must be documented
- ‚úÖ **UploadTableVirtualizer.vue already exists** (created in Phase 1.0)
- ‚úÖ **UploadTable.vue already uses the virtualizer** (no changes needed)

**Benefits of splitting virtualization:**
‚úÖ **Simplified Debugging:** Core logic proven before optimization
‚úÖ **Clean Separation:** Functional changes vs. performance changes
‚úÖ **Risk Mitigation:** Can rollback to Phase 1.0 if issues arise
‚úÖ **Clear Metrics:** Before/after performance comparison

**This phase changes:**
- Table rendering implementation (standard ‚Üí virtual)
- Scroll performance characteristics
- Memory usage patterns

**This phase does NOT change:**
- Upload button behavior
- Drag-and-drop functionality (continues to recursively traverse folders from Phase 1.0)
- Queue management logic
- Status system
- Footer calculations
- Any user-facing functionality

---

## What is Virtual Scrolling?

### The Problem (Phase 1.0)
With standard rendering, Vue creates DOM elements for **all** rows:
```
1000 files = 1000 <tr> elements in the DOM
10000 files = 10000 <tr> elements in the DOM
```
Result: Slow rendering, high memory usage, poor scroll performance

### The Solution (Phase 1.5)
With virtual scrolling, only **visible** rows are rendered:
```
1000 files visible viewport = ~20 <tr> elements in the DOM
10000 files visible viewport = ~20 <tr> elements in the DOM
```
Result: Fast rendering, constant memory, smooth 60 FPS scrolling

### How TanStack Virtual Works
1. Calculates which rows are visible in the viewport
2. Renders only those rows + a small overscan buffer
3. Uses CSS transforms to position rows correctly
4. Reuses DOM elements as user scrolls
5. Provides smooth scrolling with minimal memory

---

## Implementation Changes

**Component Being Modified:** `src/features/upload/components/UploadTableVirtualizer.vue`

### Before: Standard Rendering (Phase 1.0 - Current State)

**This is what's ALREADY in UploadTableVirtualizer.vue from Phase 1.0:**

```vue
<template>
  <!-- Simple Scrollable Body (NO VIRTUALIZATION - Phase 1.0) -->
  <div ref="scrollContainerRef" class="scroll-container">
    <div class="table-body">
      <!-- Standard rendering: Render ALL rows -->
      <UploadTableRow
        v-for="file in props.files"
        :key="file.id"
        :file="file"
        :scrollbar-width="props.scrollbarWidth"
        @cancel="handleCancel"
        @undo="handleUndo"
      />
    </div>
  </div>
</template>
```

### After: Virtual Rendering (Phase 1.5 - Your Changes)

```vue
<script setup>
import { useVirtualizer } from '@tanstack/vue-virtual';

const scrollContainer = ref(null);
const ROW_HEIGHT = 48;

const rowVirtualizer = useVirtualizer({
  count: uploadQueue.value.length,
  getScrollElement: () => scrollContainer.value,
  estimateSize: () => ROW_HEIGHT,
  overscan: 5,
  enableSmoothScroll: true
});

const virtualItems = computed(() => rowVirtualizer.value.getVirtualItems());
const totalSize = computed(() => rowVirtualizer.value.getTotalSize());
</script>

<template>
  <div ref="scrollContainer" class="table-scroll-container">
    <!-- Virtual container with full height -->
    <div class="virtual-container" :style="{ height: totalSize + 'px' }">
      <!-- Only renders visible rows + overscan -->
      <div
        v-for="virtualRow in virtualItems"
        :key="virtualRow.key"
        class="table-row"
        :style="{
          position: 'absolute',
          top: 0,
          left: 0,
          height: virtualRow.size + 'px',
          transform: `translateY(${virtualRow.start}px)`
        }"
      >
        <UploadTableRow :file="uploadQueue[virtualRow.index]" />
      </div>
    </div>
  </div>
</template>
```

---

## Component Changes

### Files to Modify

```
src/features/upload/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ UploadTableVirtualizer.vue   # ‚≠ê MODIFY: Add TanStack Virtual integration
‚îî‚îÄ‚îÄ composables/
    ‚îî‚îÄ‚îÄ useVirtualScroll.js          # ‚≠ê NEW: Virtual scrolling composable (optional)
```

**Architectural Note:**
Phase 1.0 created `UploadTableVirtualizer.vue` as an isolation layer for virtualization complexity. This component currently uses standard v-for rendering (~100 lines). Phase 1.5 will modify ONLY this file to add TanStack Virtual, keeping `UploadTable.vue` and other components unchanged.

### useVirtualScroll.js Composable

```javascript
import { ref, computed, watch } from 'vue';
import { useVirtualizer } from '@tanstack/vue-virtual';

export function useVirtualScroll(uploadQueue, scrollContainer) {
  const ROW_HEIGHT = 48;
  const OVERSCAN_COUNT = 5;

  // Create virtualizer instance
  const rowVirtualizer = useVirtualizer({
    count: computed(() => uploadQueue.value.length),
    getScrollElement: () => scrollContainer.value,
    estimateSize: () => ROW_HEIGHT,
    overscan: OVERSCAN_COUNT,
    enableSmoothScroll: true
  });

  // Watch for queue changes and update virtualizer
  watch(
    () => uploadQueue.value.length,
    () => {
      rowVirtualizer.value.measure();
    }
  );

  // Computed properties for template
  const virtualItems = computed(() => rowVirtualizer.value.getVirtualItems());
  const totalSize = computed(() => rowVirtualizer.value.getTotalSize());

  // Helper to scroll to specific row
  const scrollToRow = (index) => {
    rowVirtualizer.value.scrollToIndex(index, {
      align: 'center',
      behavior: 'smooth'
    });
  };

  return {
    virtualItems,
    totalSize,
    scrollToRow,
    rowVirtualizer
  };
}
```

### Updated UploadTableVirtualizer.vue (Phase 1.5)

```vue
<script setup>
import { ref, computed } from 'vue';
import { useVirtualizer } from '@tanstack/vue-virtual';
import UploadTableRow from './UploadTableRow.vue';

const props = defineProps({
  files: { type: Array, required: true },
  scrollbarWidth: { type: Number, required: true }
});

const emit = defineEmits(['cancel', 'undo']);

const scrollContainerRef = ref(null);
const ROW_HEIGHT = 48; // Match UploadTableRow height

// Create virtualizer instance
const rowVirtualizer = useVirtualizer({
  count: computed(() => props.files.length),
  getScrollElement: () => scrollContainerRef.value,
  estimateSize: () => ROW_HEIGHT,
  overscan: 5,
  enableSmoothScroll: true
});

// Virtual items and total size
const virtualItems = computed(() => rowVirtualizer.value.getVirtualItems());
const totalSize = computed(() => rowVirtualizer.value.getTotalSize());

// Event handlers
const handleCancel = (fileId) => emit('cancel', fileId);
const handleUndo = (fileId) => emit('undo', fileId);

// Expose for parent
defineExpose({ scrollContainerRef });
</script>

<template>
  <div ref="scrollContainerRef" class="scroll-container">
    <!-- Virtual container with dynamic height -->
    <div class="virtual-container" :style="{ height: totalSize + 'px' }">
      <!-- Only render visible rows + overscan -->
      <div
        v-for="virtualRow in virtualItems"
        :key="virtualRow.key"
        class="virtual-row"
        :style="{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: virtualRow.size + 'px',
          transform: `translateY(${virtualRow.start}px)`
        }"
      >
        <UploadTableRow
          :file="props.files[virtualRow.index]"
          :scrollbar-width="props.scrollbarWidth"
          @cancel="handleCancel"
          @undo="handleUndo"
        />
      </div>
    </div>
  </div>
</template>

<style scoped>
.scroll-container {
  flex: 1;
  position: relative;
  overflow-y: auto;
  min-height: 0;
}

.virtual-container {
  position: relative;
  width: 100%;
}

.virtual-row {
  position: absolute;
  display: block;
}
</style>
```

**Key Changes from Phase 1.0:**
- Replaced `v-for="file in props.files"` with `v-for="virtualRow in virtualItems"`
- Added `useVirtualizer` from TanStack Virtual
- Rows now use absolute positioning with CSS transforms
- Only visible rows + overscan are rendered (typically ~20 DOM elements instead of 1000+)

---

## Implementation Tasks

### Day 1: Setup & Integration

#### 1.1 Install Dependencies
- [ ] Run `npm install @tanstack/vue-virtual`
- [ ] Verify package installation
- [ ] Update package.json and lock file

#### 1.2 (Optional) Create useVirtualScroll Composable
**Note:** You can either use `useVirtualizer` directly in the component OR extract to a composable. Both approaches are valid.
- [ ] (Optional) Create `useVirtualScroll.js` composable
- [ ] (Optional) Implement virtualizer configuration
- [ ] (Optional) Add queue length watcher
- [ ] (Optional) Export virtual items and total size
- [ ] (Optional) Add scrollToRow helper function

#### 1.3 ‚≠ê MODIFY UploadTableVirtualizer.vue (EXISTING FILE - DO NOT CREATE NEW)
**File Location:** `src/features/upload/components/UploadTableVirtualizer.vue`
**Current State:** Standard v-for rendering (~140 lines)
**Target State:** Virtual rendering (~300-400 lines)

**Steps:**
- [ ] Open `src/features/upload/components/UploadTableVirtualizer.vue` (already exists!)
- [ ] Read the architectural documentation in the file header
- [ ] Import useVirtualizer from @tanstack/vue-virtual
- [ ] Create virtualizer instance with row height (48px) and overscan (5) config
- [ ] Replace `v-for="file in props.files"` with `v-for="virtualRow in virtualItems"`
- [ ] Add virtual container div with dynamic height: `:style="{ height: totalSize + 'px' }"`
- [ ] Add absolute positioning to virtual rows
- [ ] Add transform translateY for row positioning: `transform: translateY(${virtualRow.start}px)`
- [ ] Update styles for virtual scrolling (position: relative for container, position: absolute for rows)
- [ ] Keep all props/emits/expose the same (parent expects this interface!)

### Day 2: Testing & Optimization

#### 1.4 Performance Testing
- [ ] Test with 100 files (compare to Phase 1.0 baseline)
- [ ] Test with 500 files (compare to Phase 1.0 baseline)
- [ ] Test with 1000 files (should be dramatically better)
- [ ] Test with 5000 files (should maintain performance)
- [ ] Test with 10000+ files (stress test)
- [ ] Measure memory usage across all tests
- [ ] Document FPS during rapid scrolling

#### 1.5 Edge Cases
- [ ] Test adding files while scrolled down
- [ ] Test removing files while scrolled down
- [ ] Test status updates for off-screen files
- [ ] Test rapid scrolling up and down
- [ ] Test scroll position preservation
- [ ] Test with empty queue
- [ ] Test with single file

#### 1.6 Overscan Tuning
- [ ] Test different overscan values (3, 5, 10)
- [ ] Measure impact on performance
- [ ] Measure impact on scroll smoothness
- [ ] Choose optimal overscan value
- [ ] Document decision

### Day 3: Polish & Validation

#### 1.7 Visual Polish
- [ ] Ensure row alignment matches Phase 1.0
- [ ] Verify column widths match header
- [ ] Check hover states work correctly
- [ ] Verify sticky header positioning
- [ ] Test scroll bar appearance
- [ ] Ensure no visual glitches during scroll

#### 1.8 Integration Testing
- [ ] Test upload ‚Üí display flow (unchanged functionality)
- [ ] Test footer updates with virtual scrolling
- [ ] Test status changes propagate correctly
- [ ] Test cancel button on virtualized rows
- [ ] Verify all Phase 1.0 functionality still works

#### 1.9 Performance Validation
- [ ] Confirm 60 FPS during scrolling
- [ ] Confirm O(1) memory usage
- [ ] Confirm <100ms initial render for 1000 files
- [ ] Confirm smooth scrolling for 10000+ files
- [ ] Document all metrics for comparison

---

## Testing Requirements

### Performance Tests (Critical)

```javascript
describe('Virtual Scrolling Performance', () => {
  it('renders 1000 files in <100ms', async () => {
    const start = performance.now();
    await loadQueue(generateFiles(1000));
    const duration = performance.now() - start;
    expect(duration).toBeLessThan(100);
    console.log(`[PHASE 1.5] 1000 files: ${duration}ms`);
  });

  it('renders 5000 files in <150ms', async () => {
    const start = performance.now();
    await loadQueue(generateFiles(5000));
    const duration = performance.now() - start;
    expect(duration).toBeLessThan(150);
    console.log(`[PHASE 1.5] 5000 files: ${duration}ms`);
  });

  it('maintains 60 FPS during rapid scrolling', async () => {
    await loadQueue(generateFiles(5000));
    const fps = await measureScrollFPS();
    expect(fps).toBeGreaterThanOrEqual(58); // Allow 2 FPS margin
    console.log(`[PHASE 1.5] Scroll FPS: ${fps}`);
  });

  it('maintains constant memory usage', async () => {
    const baseline = await measureMemory();
    await loadQueue(generateFiles(1000));
    const after1k = await measureMemory();
    await loadQueue(generateFiles(5000));
    const after5k = await measureMemory();

    // Memory should not scale with file count
    const growth1k = after1k - baseline;
    const growth5k = after5k - baseline;
    const ratio = growth5k / growth1k;

    // Should be close to 1:1, not 5:1
    expect(ratio).toBeLessThan(2);
    console.log(`[PHASE 1.5] Memory growth ratio: ${ratio}`);
  });
});
```

### Functionality Tests (Regression Prevention)

```javascript
describe('Virtual Scrolling Functionality', () => {
  it('displays correct files in viewport', () => {});
  it('updates when queue changes', () => {});
  it('preserves scroll position on updates', () => {});
  it('handles empty queue', () => {});
  it('handles single file', () => {});
  it('renders rows with correct data', () => {});
});

describe('Phase 1.0 Functionality Regression', () => {
  it('upload buttons still work', () => {});
  it('drag-and-drop still works (recursive folder traversal)', () => {});
  it('files appear in table immediately', () => {});
  it('status updates propagate correctly', () => {});
  it('footer counts update correctly', () => {});
  it('all 7 status states display correctly', () => {});
  it('cancel button works on virtualized rows', () => {});
});
```

### Visual Tests

```javascript
describe('Virtual Scrolling Visual Consistency', () => {
  it('row heights match Phase 1.0', () => {});
  it('column widths match header', () => {});
  it('hover states work correctly', () => {});
  it('no visual glitches during scroll', () => {});
  it('sticky header remains visible', () => {});
});
```

### Manual Testing Scenarios

1. **Performance Comparison:**
   - Load 500 files ‚Üí Compare to Phase 1.0 baseline
   - Load 1000 files ‚Üí Should be dramatically better than Phase 1.0
   - Load 5000 files ‚Üí Should remain smooth
   - Scroll rapidly ‚Üí Should maintain 60 FPS

2. **Edge Cases:**
   - Add files while scrolled to bottom
   - Remove files while scrolled to middle
   - Change status of off-screen file
   - Scroll to top, then bottom, then middle rapidly

3. **Regression Testing:**
   - Run all Phase 1.0 manual test scenarios
   - Test drag-and-drop with folders (verify recursive traversal still works)
   - Verify identical functionality
   - Verify identical visual appearance

---

## Success Criteria

### Performance Requirements (Must Achieve)
- [ ] 1000 files render in <100ms
- [ ] 5000 files render in <150ms
- [ ] Scrolling maintains 60 FPS (58+ acceptable)
- [ ] Memory usage stays constant O(1)
- [ ] No frame drops during status updates
- [ ] Scroll position preserved during queue updates

### Functionality Requirements (No Regressions)
- [ ] All Phase 1.0 functionality works identically
- [ ] Upload buttons unchanged
- [ ] Queue management unchanged
- [ ] Status system unchanged
- [ ] Footer calculations unchanged
- [ ] Visual appearance matches Phase 1.0

### Technical Requirements
- [ ] Only visible rows + overscan rendered
- [ ] DOM element count stays constant
- [ ] Virtual container height matches total content
- [ ] Row positioning uses CSS transforms
- [ ] No console warnings or errors

---

## Performance Benchmarks

### Target Performance (Phase 1.5)

| File Count | Target Render Time | Target Scroll FPS | Target Memory |
|------------|-------------------|-------------------|---------------|
| 100 files | <50ms | 60 FPS | ~50MB |
| 500 files | <75ms | 60 FPS | ~50MB |
| 1000 files | <100ms | 60 FPS | ~50MB |
| 5000 files | <150ms | 60 FPS | ~50MB |
| 10000 files | <200ms | 60 FPS | ~50MB |

### Comparison to Phase 1.0

Expected improvements:
- **Initial render:** 10-20x faster for 1000+ files
- **Scroll performance:** 2-4x better FPS
- **Memory usage:** 5-10x reduction (O(n) ‚Üí O(1))

**Performance Logging:**
```javascript
console.log('[PHASE 1.5] Virtualizer initialized');
console.log('[PHASE 1.5] 1000 files rendered: Xms (vs Phase 1.0: Yms)');
console.log('[PHASE 1.5] Visible rows: X of Y total');
console.log('[PHASE 1.5] Scroll FPS: X (vs Phase 1.0: Y)');
console.log('[PHASE 1.5] Memory: XMB (vs Phase 1.0: YMB)');
console.log('[PHASE 1.5] DOM elements: X (vs Phase 1.0: Y)');
```

---

## Dependencies

### NPM Packages (New)
```bash
npm install @tanstack/vue-virtual
```

### Internal Dependencies
- Phase 1.0 components (all unchanged except UploadTable.vue)
- DocumentTable.css (styling reference)

---

## Rollout Plan

### Development Schedule

**Day 1:** Install TanStack, create composable, integrate with UploadTable.vue
**Day 2:** Performance testing, edge case testing, overscan tuning
**Day 3:** Visual polish, regression testing, final validation

### Testing Steps
1. Performance benchmarks (compare to Phase 1.0)
2. Functionality regression tests
3. Edge case testing
4. Visual consistency checks
5. Browser compatibility
6. Final validation

### Deployment
- Deploy to `/testing` route (replace Phase 1.0)
- Announce performance improvements
- Monitor for any issues
- Keep Phase 1.0 code in git history for rollback if needed
- Collect user feedback on performance

---

## Known Issues / Risks

### Technical Risks
| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Virtual scrolling breaks existing functionality | Low | High | Comprehensive regression testing |
| Performance targets not met | Low | Medium | Can adjust overscan, row height |
| Visual glitches during scroll | Low | Medium | CSS refinement, browser testing |
| TanStack Virtual compatibility issues | Very Low | High | Well-established library, good docs |

### Rollback Plan
If Phase 1.5 introduces bugs or doesn't meet performance targets:
1. Revert UploadTable.vue to Phase 1.0 version
2. Remove useVirtualScroll.js
3. Can uninstall @tanstack/vue-virtual (optional)
4. Phase 1.0 remains fully functional

---

## Next Phase Preview

**Phase 2:** Core Actions
- Cancel button implementation
- Undo functionality
- Upload Now button
- Duplicate promotion algorithm

Phase 2 adds user actions to the high-performance virtualized table.

---

## Notes

- Phase 1.5 is **purely a performance optimization**
- No functionality changes - only implementation changes
- Must not introduce any bugs or regressions
- All Phase 1.0 tests must continue to pass
- Document before/after metrics for team review
- Keep code changes isolated to UploadTable.vue and new composable
- Can be rolled back to Phase 1.0 if needed

---

**Phase Status:** ‚¨ú Not Started (Blocked by Phase 1.0)
**Last Updated:** 2025-11-11
**Assignee:** TBD

**Architectural Preparation (Phase 1.0):**
- ‚úÖ `UploadTableVirtualizer.vue` created as isolation layer for virtualization complexity
- ‚úÖ Clear boundary established between business logic (UploadTable.vue) and performance optimization (UploadTableVirtualizer.vue)
- ‚úÖ Phase 1.5 will modify ONLY UploadTableVirtualizer.vue, leaving other components unchanged

---

## üö® CRITICAL REMINDERS FOR PHASE 1.5 IMPLEMENTATION

### Before You Start Coding

1. **READ THE FILE HEADER** of `UploadTableVirtualizer.vue` - it has 40+ lines of architectural documentation explaining:
   - WHY this component exists (scope defense against tight coupling)
   - WHAT belongs in this file (virtualization mechanics only)
   - WHAT must NOT be in this file (business logic, selection, stats, etc.)
   - WHY it's allowed to exceed 300 lines (technical necessity of virtualization)

2. **DO NOT CREATE NEW COMPONENTS** - `UploadTableVirtualizer.vue` already exists. You are MODIFYING an existing file.

3. **DO NOT MODIFY THE PARENT** - `UploadTable.vue` is already set up correctly. It passes props, receives emits, and accesses the exposed ref. Leave it alone.

4. **PRESERVE THE INTERFACE:**
   - Props: `files` (Array), `scrollbarWidth` (Number)
   - Emits: `cancel`, `undo`
   - Expose: `scrollContainerRef`
   - The parent component expects this exact interface!

5. **KEEP BUSINESS LOGIC OUT** - If you're tempted to add selection logic, footer stats, empty state, or drag-drop handling to this file, STOP. Those belong in `UploadTable.vue`.

### Success Criteria

‚úÖ Only `UploadTableVirtualizer.vue` was modified
‚úÖ Props/emits/expose interface unchanged
‚úÖ All Phase 1.0 functionality still works
‚úÖ Performance dramatically improved for 1000+ files
‚úÖ No business logic leaked into virtualizer
‚úÖ File header documentation still accurate

### If You Get Confused

**Go back and read the "üéØ STARTING POINT" section at the top of this document!**
